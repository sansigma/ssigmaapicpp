// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ssigmaapi/markethub/v1/markethub.proto

#ifndef PROTOBUF_INCLUDED_ssigmaapi_2fmarkethub_2fv1_2fmarkethub_2eproto
#define PROTOBUF_INCLUDED_ssigmaapi_2fmarkethub_2fv1_2fmarkethub_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "ssigmaapi/type/market.pb.h"
#include "ssigmaapi/type/trade.pb.h"
#include "ssigmaapi/type/orderbook.pb.h"
#include "google/api/annotations.pb.h"
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_ssigmaapi_2fmarkethub_2fv1_2fmarkethub_2eproto 

namespace protobuf_ssigmaapi_2fmarkethub_2fv1_2fmarkethub_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[9];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_ssigmaapi_2fmarkethub_2fv1_2fmarkethub_2eproto
namespace ssigmaapi {
namespace markethub {
namespace v1 {
class ExchangeStatus;
class ExchangeStatusDefaultTypeInternal;
extern ExchangeStatusDefaultTypeInternal _ExchangeStatus_default_instance_;
class GetOrderBooksRequest;
class GetOrderBooksRequestDefaultTypeInternal;
extern GetOrderBooksRequestDefaultTypeInternal _GetOrderBooksRequest_default_instance_;
class GetOrderBooksResponse;
class GetOrderBooksResponseDefaultTypeInternal;
extern GetOrderBooksResponseDefaultTypeInternal _GetOrderBooksResponse_default_instance_;
class GetTradesAndOrderBooksRequest;
class GetTradesAndOrderBooksRequestDefaultTypeInternal;
extern GetTradesAndOrderBooksRequestDefaultTypeInternal _GetTradesAndOrderBooksRequest_default_instance_;
class GetTradesAndOrderBooksResponse;
class GetTradesAndOrderBooksResponseDefaultTypeInternal;
extern GetTradesAndOrderBooksResponseDefaultTypeInternal _GetTradesAndOrderBooksResponse_default_instance_;
class GetTradesRequest;
class GetTradesRequestDefaultTypeInternal;
extern GetTradesRequestDefaultTypeInternal _GetTradesRequest_default_instance_;
class GetTradesResponse;
class GetTradesResponseDefaultTypeInternal;
extern GetTradesResponseDefaultTypeInternal _GetTradesResponse_default_instance_;
class TradeWithAdditionalInfo;
class TradeWithAdditionalInfoDefaultTypeInternal;
extern TradeWithAdditionalInfoDefaultTypeInternal _TradeWithAdditionalInfo_default_instance_;
class TradesWithMarket;
class TradesWithMarketDefaultTypeInternal;
extern TradesWithMarketDefaultTypeInternal _TradesWithMarket_default_instance_;
}  // namespace v1
}  // namespace markethub
}  // namespace ssigmaapi
namespace google {
namespace protobuf {
template<> ::ssigmaapi::markethub::v1::ExchangeStatus* Arena::CreateMaybeMessage<::ssigmaapi::markethub::v1::ExchangeStatus>(Arena*);
template<> ::ssigmaapi::markethub::v1::GetOrderBooksRequest* Arena::CreateMaybeMessage<::ssigmaapi::markethub::v1::GetOrderBooksRequest>(Arena*);
template<> ::ssigmaapi::markethub::v1::GetOrderBooksResponse* Arena::CreateMaybeMessage<::ssigmaapi::markethub::v1::GetOrderBooksResponse>(Arena*);
template<> ::ssigmaapi::markethub::v1::GetTradesAndOrderBooksRequest* Arena::CreateMaybeMessage<::ssigmaapi::markethub::v1::GetTradesAndOrderBooksRequest>(Arena*);
template<> ::ssigmaapi::markethub::v1::GetTradesAndOrderBooksResponse* Arena::CreateMaybeMessage<::ssigmaapi::markethub::v1::GetTradesAndOrderBooksResponse>(Arena*);
template<> ::ssigmaapi::markethub::v1::GetTradesRequest* Arena::CreateMaybeMessage<::ssigmaapi::markethub::v1::GetTradesRequest>(Arena*);
template<> ::ssigmaapi::markethub::v1::GetTradesResponse* Arena::CreateMaybeMessage<::ssigmaapi::markethub::v1::GetTradesResponse>(Arena*);
template<> ::ssigmaapi::markethub::v1::TradeWithAdditionalInfo* Arena::CreateMaybeMessage<::ssigmaapi::markethub::v1::TradeWithAdditionalInfo>(Arena*);
template<> ::ssigmaapi::markethub::v1::TradesWithMarket* Arena::CreateMaybeMessage<::ssigmaapi::markethub::v1::TradesWithMarket>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace ssigmaapi {
namespace markethub {
namespace v1 {

// ===================================================================

class GetTradesRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ssigmaapi.markethub.v1.GetTradesRequest) */ {
 public:
  GetTradesRequest();
  virtual ~GetTradesRequest();

  GetTradesRequest(const GetTradesRequest& from);

  inline GetTradesRequest& operator=(const GetTradesRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetTradesRequest(GetTradesRequest&& from) noexcept
    : GetTradesRequest() {
    *this = ::std::move(from);
  }

  inline GetTradesRequest& operator=(GetTradesRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetTradesRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetTradesRequest* internal_default_instance() {
    return reinterpret_cast<const GetTradesRequest*>(
               &_GetTradesRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(GetTradesRequest* other);
  friend void swap(GetTradesRequest& a, GetTradesRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetTradesRequest* New() const final {
    return CreateMaybeMessage<GetTradesRequest>(NULL);
  }

  GetTradesRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GetTradesRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GetTradesRequest& from);
  void MergeFrom(const GetTradesRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetTradesRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .ssigmaapi.type.Market markets = 1;
  int markets_size() const;
  void clear_markets();
  static const int kMarketsFieldNumber = 1;
  ::ssigmaapi::type::Market* mutable_markets(int index);
  ::google::protobuf::RepeatedPtrField< ::ssigmaapi::type::Market >*
      mutable_markets();
  const ::ssigmaapi::type::Market& markets(int index) const;
  ::ssigmaapi::type::Market* add_markets();
  const ::google::protobuf::RepeatedPtrField< ::ssigmaapi::type::Market >&
      markets() const;

  // int64 velocity_windowing_size = 2;
  void clear_velocity_windowing_size();
  static const int kVelocityWindowingSizeFieldNumber = 2;
  ::google::protobuf::int64 velocity_windowing_size() const;
  void set_velocity_windowing_size(::google::protobuf::int64 value);

  // int64 volatility_windowing_size = 3;
  void clear_volatility_windowing_size();
  static const int kVolatilityWindowingSizeFieldNumber = 3;
  ::google::protobuf::int64 volatility_windowing_size() const;
  void set_volatility_windowing_size(::google::protobuf::int64 value);

  // int64 volume_windowing_size = 4;
  void clear_volume_windowing_size();
  static const int kVolumeWindowingSizeFieldNumber = 4;
  ::google::protobuf::int64 volume_windowing_size() const;
  void set_volume_windowing_size(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:ssigmaapi.markethub.v1.GetTradesRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::ssigmaapi::type::Market > markets_;
  ::google::protobuf::int64 velocity_windowing_size_;
  ::google::protobuf::int64 volatility_windowing_size_;
  ::google::protobuf::int64 volume_windowing_size_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_ssigmaapi_2fmarkethub_2fv1_2fmarkethub_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetTradesResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ssigmaapi.markethub.v1.GetTradesResponse) */ {
 public:
  GetTradesResponse();
  virtual ~GetTradesResponse();

  GetTradesResponse(const GetTradesResponse& from);

  inline GetTradesResponse& operator=(const GetTradesResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetTradesResponse(GetTradesResponse&& from) noexcept
    : GetTradesResponse() {
    *this = ::std::move(from);
  }

  inline GetTradesResponse& operator=(GetTradesResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetTradesResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetTradesResponse* internal_default_instance() {
    return reinterpret_cast<const GetTradesResponse*>(
               &_GetTradesResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(GetTradesResponse* other);
  friend void swap(GetTradesResponse& a, GetTradesResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetTradesResponse* New() const final {
    return CreateMaybeMessage<GetTradesResponse>(NULL);
  }

  GetTradesResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GetTradesResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GetTradesResponse& from);
  void MergeFrom(const GetTradesResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetTradesResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .ssigmaapi.markethub.v1.TradesWithMarket trades_with_market = 1;
  int trades_with_market_size() const;
  void clear_trades_with_market();
  static const int kTradesWithMarketFieldNumber = 1;
  ::ssigmaapi::markethub::v1::TradesWithMarket* mutable_trades_with_market(int index);
  ::google::protobuf::RepeatedPtrField< ::ssigmaapi::markethub::v1::TradesWithMarket >*
      mutable_trades_with_market();
  const ::ssigmaapi::markethub::v1::TradesWithMarket& trades_with_market(int index) const;
  ::ssigmaapi::markethub::v1::TradesWithMarket* add_trades_with_market();
  const ::google::protobuf::RepeatedPtrField< ::ssigmaapi::markethub::v1::TradesWithMarket >&
      trades_with_market() const;

  // repeated .ssigmaapi.markethub.v1.ExchangeStatus exchange_status = 2;
  int exchange_status_size() const;
  void clear_exchange_status();
  static const int kExchangeStatusFieldNumber = 2;
  ::ssigmaapi::markethub::v1::ExchangeStatus* mutable_exchange_status(int index);
  ::google::protobuf::RepeatedPtrField< ::ssigmaapi::markethub::v1::ExchangeStatus >*
      mutable_exchange_status();
  const ::ssigmaapi::markethub::v1::ExchangeStatus& exchange_status(int index) const;
  ::ssigmaapi::markethub::v1::ExchangeStatus* add_exchange_status();
  const ::google::protobuf::RepeatedPtrField< ::ssigmaapi::markethub::v1::ExchangeStatus >&
      exchange_status() const;

  // @@protoc_insertion_point(class_scope:ssigmaapi.markethub.v1.GetTradesResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::ssigmaapi::markethub::v1::TradesWithMarket > trades_with_market_;
  ::google::protobuf::RepeatedPtrField< ::ssigmaapi::markethub::v1::ExchangeStatus > exchange_status_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_ssigmaapi_2fmarkethub_2fv1_2fmarkethub_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetOrderBooksRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ssigmaapi.markethub.v1.GetOrderBooksRequest) */ {
 public:
  GetOrderBooksRequest();
  virtual ~GetOrderBooksRequest();

  GetOrderBooksRequest(const GetOrderBooksRequest& from);

  inline GetOrderBooksRequest& operator=(const GetOrderBooksRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetOrderBooksRequest(GetOrderBooksRequest&& from) noexcept
    : GetOrderBooksRequest() {
    *this = ::std::move(from);
  }

  inline GetOrderBooksRequest& operator=(GetOrderBooksRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetOrderBooksRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetOrderBooksRequest* internal_default_instance() {
    return reinterpret_cast<const GetOrderBooksRequest*>(
               &_GetOrderBooksRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(GetOrderBooksRequest* other);
  friend void swap(GetOrderBooksRequest& a, GetOrderBooksRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetOrderBooksRequest* New() const final {
    return CreateMaybeMessage<GetOrderBooksRequest>(NULL);
  }

  GetOrderBooksRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GetOrderBooksRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GetOrderBooksRequest& from);
  void MergeFrom(const GetOrderBooksRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetOrderBooksRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .ssigmaapi.type.Market market = 1;
  int market_size() const;
  void clear_market();
  static const int kMarketFieldNumber = 1;
  ::ssigmaapi::type::Market* mutable_market(int index);
  ::google::protobuf::RepeatedPtrField< ::ssigmaapi::type::Market >*
      mutable_market();
  const ::ssigmaapi::type::Market& market(int index) const;
  ::ssigmaapi::type::Market* add_market();
  const ::google::protobuf::RepeatedPtrField< ::ssigmaapi::type::Market >&
      market() const;

  // @@protoc_insertion_point(class_scope:ssigmaapi.markethub.v1.GetOrderBooksRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::ssigmaapi::type::Market > market_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_ssigmaapi_2fmarkethub_2fv1_2fmarkethub_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetOrderBooksResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ssigmaapi.markethub.v1.GetOrderBooksResponse) */ {
 public:
  GetOrderBooksResponse();
  virtual ~GetOrderBooksResponse();

  GetOrderBooksResponse(const GetOrderBooksResponse& from);

  inline GetOrderBooksResponse& operator=(const GetOrderBooksResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetOrderBooksResponse(GetOrderBooksResponse&& from) noexcept
    : GetOrderBooksResponse() {
    *this = ::std::move(from);
  }

  inline GetOrderBooksResponse& operator=(GetOrderBooksResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetOrderBooksResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetOrderBooksResponse* internal_default_instance() {
    return reinterpret_cast<const GetOrderBooksResponse*>(
               &_GetOrderBooksResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(GetOrderBooksResponse* other);
  friend void swap(GetOrderBooksResponse& a, GetOrderBooksResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetOrderBooksResponse* New() const final {
    return CreateMaybeMessage<GetOrderBooksResponse>(NULL);
  }

  GetOrderBooksResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GetOrderBooksResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GetOrderBooksResponse& from);
  void MergeFrom(const GetOrderBooksResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetOrderBooksResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .ssigmaapi.type.OrderBook all = 1;
  int all_size() const;
  void clear_all();
  static const int kAllFieldNumber = 1;
  ::ssigmaapi::type::OrderBook* mutable_all(int index);
  ::google::protobuf::RepeatedPtrField< ::ssigmaapi::type::OrderBook >*
      mutable_all();
  const ::ssigmaapi::type::OrderBook& all(int index) const;
  ::ssigmaapi::type::OrderBook* add_all();
  const ::google::protobuf::RepeatedPtrField< ::ssigmaapi::type::OrderBook >&
      all() const;

  // repeated .ssigmaapi.markethub.v1.ExchangeStatus exchange_status = 3;
  int exchange_status_size() const;
  void clear_exchange_status();
  static const int kExchangeStatusFieldNumber = 3;
  ::ssigmaapi::markethub::v1::ExchangeStatus* mutable_exchange_status(int index);
  ::google::protobuf::RepeatedPtrField< ::ssigmaapi::markethub::v1::ExchangeStatus >*
      mutable_exchange_status();
  const ::ssigmaapi::markethub::v1::ExchangeStatus& exchange_status(int index) const;
  ::ssigmaapi::markethub::v1::ExchangeStatus* add_exchange_status();
  const ::google::protobuf::RepeatedPtrField< ::ssigmaapi::markethub::v1::ExchangeStatus >&
      exchange_status() const;

  // int64 timestamp = 2;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 2;
  ::google::protobuf::int64 timestamp() const;
  void set_timestamp(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:ssigmaapi.markethub.v1.GetOrderBooksResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::ssigmaapi::type::OrderBook > all_;
  ::google::protobuf::RepeatedPtrField< ::ssigmaapi::markethub::v1::ExchangeStatus > exchange_status_;
  ::google::protobuf::int64 timestamp_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_ssigmaapi_2fmarkethub_2fv1_2fmarkethub_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetTradesAndOrderBooksRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ssigmaapi.markethub.v1.GetTradesAndOrderBooksRequest) */ {
 public:
  GetTradesAndOrderBooksRequest();
  virtual ~GetTradesAndOrderBooksRequest();

  GetTradesAndOrderBooksRequest(const GetTradesAndOrderBooksRequest& from);

  inline GetTradesAndOrderBooksRequest& operator=(const GetTradesAndOrderBooksRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetTradesAndOrderBooksRequest(GetTradesAndOrderBooksRequest&& from) noexcept
    : GetTradesAndOrderBooksRequest() {
    *this = ::std::move(from);
  }

  inline GetTradesAndOrderBooksRequest& operator=(GetTradesAndOrderBooksRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetTradesAndOrderBooksRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetTradesAndOrderBooksRequest* internal_default_instance() {
    return reinterpret_cast<const GetTradesAndOrderBooksRequest*>(
               &_GetTradesAndOrderBooksRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(GetTradesAndOrderBooksRequest* other);
  friend void swap(GetTradesAndOrderBooksRequest& a, GetTradesAndOrderBooksRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetTradesAndOrderBooksRequest* New() const final {
    return CreateMaybeMessage<GetTradesAndOrderBooksRequest>(NULL);
  }

  GetTradesAndOrderBooksRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GetTradesAndOrderBooksRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GetTradesAndOrderBooksRequest& from);
  void MergeFrom(const GetTradesAndOrderBooksRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetTradesAndOrderBooksRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .ssigmaapi.markethub.v1.GetTradesRequest trades_req = 1;
  bool has_trades_req() const;
  void clear_trades_req();
  static const int kTradesReqFieldNumber = 1;
  private:
  const ::ssigmaapi::markethub::v1::GetTradesRequest& _internal_trades_req() const;
  public:
  const ::ssigmaapi::markethub::v1::GetTradesRequest& trades_req() const;
  ::ssigmaapi::markethub::v1::GetTradesRequest* release_trades_req();
  ::ssigmaapi::markethub::v1::GetTradesRequest* mutable_trades_req();
  void set_allocated_trades_req(::ssigmaapi::markethub::v1::GetTradesRequest* trades_req);

  // .ssigmaapi.markethub.v1.GetOrderBooksRequest orderbooks_req = 2;
  bool has_orderbooks_req() const;
  void clear_orderbooks_req();
  static const int kOrderbooksReqFieldNumber = 2;
  private:
  const ::ssigmaapi::markethub::v1::GetOrderBooksRequest& _internal_orderbooks_req() const;
  public:
  const ::ssigmaapi::markethub::v1::GetOrderBooksRequest& orderbooks_req() const;
  ::ssigmaapi::markethub::v1::GetOrderBooksRequest* release_orderbooks_req();
  ::ssigmaapi::markethub::v1::GetOrderBooksRequest* mutable_orderbooks_req();
  void set_allocated_orderbooks_req(::ssigmaapi::markethub::v1::GetOrderBooksRequest* orderbooks_req);

  // @@protoc_insertion_point(class_scope:ssigmaapi.markethub.v1.GetTradesAndOrderBooksRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::ssigmaapi::markethub::v1::GetTradesRequest* trades_req_;
  ::ssigmaapi::markethub::v1::GetOrderBooksRequest* orderbooks_req_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_ssigmaapi_2fmarkethub_2fv1_2fmarkethub_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetTradesAndOrderBooksResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ssigmaapi.markethub.v1.GetTradesAndOrderBooksResponse) */ {
 public:
  GetTradesAndOrderBooksResponse();
  virtual ~GetTradesAndOrderBooksResponse();

  GetTradesAndOrderBooksResponse(const GetTradesAndOrderBooksResponse& from);

  inline GetTradesAndOrderBooksResponse& operator=(const GetTradesAndOrderBooksResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetTradesAndOrderBooksResponse(GetTradesAndOrderBooksResponse&& from) noexcept
    : GetTradesAndOrderBooksResponse() {
    *this = ::std::move(from);
  }

  inline GetTradesAndOrderBooksResponse& operator=(GetTradesAndOrderBooksResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetTradesAndOrderBooksResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetTradesAndOrderBooksResponse* internal_default_instance() {
    return reinterpret_cast<const GetTradesAndOrderBooksResponse*>(
               &_GetTradesAndOrderBooksResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(GetTradesAndOrderBooksResponse* other);
  friend void swap(GetTradesAndOrderBooksResponse& a, GetTradesAndOrderBooksResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetTradesAndOrderBooksResponse* New() const final {
    return CreateMaybeMessage<GetTradesAndOrderBooksResponse>(NULL);
  }

  GetTradesAndOrderBooksResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GetTradesAndOrderBooksResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GetTradesAndOrderBooksResponse& from);
  void MergeFrom(const GetTradesAndOrderBooksResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetTradesAndOrderBooksResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .ssigmaapi.markethub.v1.ExchangeStatus exchange_status = 3;
  int exchange_status_size() const;
  void clear_exchange_status();
  static const int kExchangeStatusFieldNumber = 3;
  ::ssigmaapi::markethub::v1::ExchangeStatus* mutable_exchange_status(int index);
  ::google::protobuf::RepeatedPtrField< ::ssigmaapi::markethub::v1::ExchangeStatus >*
      mutable_exchange_status();
  const ::ssigmaapi::markethub::v1::ExchangeStatus& exchange_status(int index) const;
  ::ssigmaapi::markethub::v1::ExchangeStatus* add_exchange_status();
  const ::google::protobuf::RepeatedPtrField< ::ssigmaapi::markethub::v1::ExchangeStatus >&
      exchange_status() const;

  // .ssigmaapi.markethub.v1.GetTradesResponse trades_res = 1;
  bool has_trades_res() const;
  void clear_trades_res();
  static const int kTradesResFieldNumber = 1;
  private:
  const ::ssigmaapi::markethub::v1::GetTradesResponse& _internal_trades_res() const;
  public:
  const ::ssigmaapi::markethub::v1::GetTradesResponse& trades_res() const;
  ::ssigmaapi::markethub::v1::GetTradesResponse* release_trades_res();
  ::ssigmaapi::markethub::v1::GetTradesResponse* mutable_trades_res();
  void set_allocated_trades_res(::ssigmaapi::markethub::v1::GetTradesResponse* trades_res);

  // .ssigmaapi.markethub.v1.GetOrderBooksResponse orderbooks_res = 2;
  bool has_orderbooks_res() const;
  void clear_orderbooks_res();
  static const int kOrderbooksResFieldNumber = 2;
  private:
  const ::ssigmaapi::markethub::v1::GetOrderBooksResponse& _internal_orderbooks_res() const;
  public:
  const ::ssigmaapi::markethub::v1::GetOrderBooksResponse& orderbooks_res() const;
  ::ssigmaapi::markethub::v1::GetOrderBooksResponse* release_orderbooks_res();
  ::ssigmaapi::markethub::v1::GetOrderBooksResponse* mutable_orderbooks_res();
  void set_allocated_orderbooks_res(::ssigmaapi::markethub::v1::GetOrderBooksResponse* orderbooks_res);

  // @@protoc_insertion_point(class_scope:ssigmaapi.markethub.v1.GetTradesAndOrderBooksResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::ssigmaapi::markethub::v1::ExchangeStatus > exchange_status_;
  ::ssigmaapi::markethub::v1::GetTradesResponse* trades_res_;
  ::ssigmaapi::markethub::v1::GetOrderBooksResponse* orderbooks_res_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_ssigmaapi_2fmarkethub_2fv1_2fmarkethub_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TradeWithAdditionalInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ssigmaapi.markethub.v1.TradeWithAdditionalInfo) */ {
 public:
  TradeWithAdditionalInfo();
  virtual ~TradeWithAdditionalInfo();

  TradeWithAdditionalInfo(const TradeWithAdditionalInfo& from);

  inline TradeWithAdditionalInfo& operator=(const TradeWithAdditionalInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TradeWithAdditionalInfo(TradeWithAdditionalInfo&& from) noexcept
    : TradeWithAdditionalInfo() {
    *this = ::std::move(from);
  }

  inline TradeWithAdditionalInfo& operator=(TradeWithAdditionalInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const TradeWithAdditionalInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TradeWithAdditionalInfo* internal_default_instance() {
    return reinterpret_cast<const TradeWithAdditionalInfo*>(
               &_TradeWithAdditionalInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(TradeWithAdditionalInfo* other);
  friend void swap(TradeWithAdditionalInfo& a, TradeWithAdditionalInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TradeWithAdditionalInfo* New() const final {
    return CreateMaybeMessage<TradeWithAdditionalInfo>(NULL);
  }

  TradeWithAdditionalInfo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TradeWithAdditionalInfo>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TradeWithAdditionalInfo& from);
  void MergeFrom(const TradeWithAdditionalInfo& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TradeWithAdditionalInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .ssigmaapi.type.Trade trade = 1;
  bool has_trade() const;
  void clear_trade();
  static const int kTradeFieldNumber = 1;
  private:
  const ::ssigmaapi::type::Trade& _internal_trade() const;
  public:
  const ::ssigmaapi::type::Trade& trade() const;
  ::ssigmaapi::type::Trade* release_trade();
  ::ssigmaapi::type::Trade* mutable_trade();
  void set_allocated_trade(::ssigmaapi::type::Trade* trade);

  // double velocity = 2;
  void clear_velocity();
  static const int kVelocityFieldNumber = 2;
  double velocity() const;
  void set_velocity(double value);

  // double acceleration = 3;
  void clear_acceleration();
  static const int kAccelerationFieldNumber = 3;
  double acceleration() const;
  void set_acceleration(double value);

  // double volatility = 4;
  void clear_volatility();
  static const int kVolatilityFieldNumber = 4;
  double volatility() const;
  void set_volatility(double value);

  // double volume_base = 5;
  void clear_volume_base();
  static const int kVolumeBaseFieldNumber = 5;
  double volume_base() const;
  void set_volume_base(double value);

  // double volume_quote = 6;
  void clear_volume_quote();
  static const int kVolumeQuoteFieldNumber = 6;
  double volume_quote() const;
  void set_volume_quote(double value);

  // double momentum_rate = 7;
  void clear_momentum_rate();
  static const int kMomentumRateFieldNumber = 7;
  double momentum_rate() const;
  void set_momentum_rate(double value);

  // int64 velocity_windowing_size = 8;
  void clear_velocity_windowing_size();
  static const int kVelocityWindowingSizeFieldNumber = 8;
  ::google::protobuf::int64 velocity_windowing_size() const;
  void set_velocity_windowing_size(::google::protobuf::int64 value);

  // int64 volatility_windowing_size = 9;
  void clear_volatility_windowing_size();
  static const int kVolatilityWindowingSizeFieldNumber = 9;
  ::google::protobuf::int64 volatility_windowing_size() const;
  void set_volatility_windowing_size(::google::protobuf::int64 value);

  // int64 volume_windowing_size = 10;
  void clear_volume_windowing_size();
  static const int kVolumeWindowingSizeFieldNumber = 10;
  ::google::protobuf::int64 volume_windowing_size() const;
  void set_volume_windowing_size(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:ssigmaapi.markethub.v1.TradeWithAdditionalInfo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::ssigmaapi::type::Trade* trade_;
  double velocity_;
  double acceleration_;
  double volatility_;
  double volume_base_;
  double volume_quote_;
  double momentum_rate_;
  ::google::protobuf::int64 velocity_windowing_size_;
  ::google::protobuf::int64 volatility_windowing_size_;
  ::google::protobuf::int64 volume_windowing_size_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_ssigmaapi_2fmarkethub_2fv1_2fmarkethub_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TradesWithMarket : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ssigmaapi.markethub.v1.TradesWithMarket) */ {
 public:
  TradesWithMarket();
  virtual ~TradesWithMarket();

  TradesWithMarket(const TradesWithMarket& from);

  inline TradesWithMarket& operator=(const TradesWithMarket& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TradesWithMarket(TradesWithMarket&& from) noexcept
    : TradesWithMarket() {
    *this = ::std::move(from);
  }

  inline TradesWithMarket& operator=(TradesWithMarket&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const TradesWithMarket& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TradesWithMarket* internal_default_instance() {
    return reinterpret_cast<const TradesWithMarket*>(
               &_TradesWithMarket_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(TradesWithMarket* other);
  friend void swap(TradesWithMarket& a, TradesWithMarket& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TradesWithMarket* New() const final {
    return CreateMaybeMessage<TradesWithMarket>(NULL);
  }

  TradesWithMarket* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TradesWithMarket>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TradesWithMarket& from);
  void MergeFrom(const TradesWithMarket& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TradesWithMarket* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .ssigmaapi.markethub.v1.TradeWithAdditionalInfo trades = 2;
  int trades_size() const;
  void clear_trades();
  static const int kTradesFieldNumber = 2;
  ::ssigmaapi::markethub::v1::TradeWithAdditionalInfo* mutable_trades(int index);
  ::google::protobuf::RepeatedPtrField< ::ssigmaapi::markethub::v1::TradeWithAdditionalInfo >*
      mutable_trades();
  const ::ssigmaapi::markethub::v1::TradeWithAdditionalInfo& trades(int index) const;
  ::ssigmaapi::markethub::v1::TradeWithAdditionalInfo* add_trades();
  const ::google::protobuf::RepeatedPtrField< ::ssigmaapi::markethub::v1::TradeWithAdditionalInfo >&
      trades() const;

  // .ssigmaapi.type.Market market = 1;
  bool has_market() const;
  void clear_market();
  static const int kMarketFieldNumber = 1;
  private:
  const ::ssigmaapi::type::Market& _internal_market() const;
  public:
  const ::ssigmaapi::type::Market& market() const;
  ::ssigmaapi::type::Market* release_market();
  ::ssigmaapi::type::Market* mutable_market();
  void set_allocated_market(::ssigmaapi::type::Market* market);

  // @@protoc_insertion_point(class_scope:ssigmaapi.markethub.v1.TradesWithMarket)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::ssigmaapi::markethub::v1::TradeWithAdditionalInfo > trades_;
  ::ssigmaapi::type::Market* market_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_ssigmaapi_2fmarkethub_2fv1_2fmarkethub_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ExchangeStatus : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ssigmaapi.markethub.v1.ExchangeStatus) */ {
 public:
  ExchangeStatus();
  virtual ~ExchangeStatus();

  ExchangeStatus(const ExchangeStatus& from);

  inline ExchangeStatus& operator=(const ExchangeStatus& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ExchangeStatus(ExchangeStatus&& from) noexcept
    : ExchangeStatus() {
    *this = ::std::move(from);
  }

  inline ExchangeStatus& operator=(ExchangeStatus&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ExchangeStatus& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ExchangeStatus* internal_default_instance() {
    return reinterpret_cast<const ExchangeStatus*>(
               &_ExchangeStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(ExchangeStatus* other);
  friend void swap(ExchangeStatus& a, ExchangeStatus& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ExchangeStatus* New() const final {
    return CreateMaybeMessage<ExchangeStatus>(NULL);
  }

  ExchangeStatus* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ExchangeStatus>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ExchangeStatus& from);
  void MergeFrom(const ExchangeStatus& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ExchangeStatus* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string exchange = 1;
  void clear_exchange();
  static const int kExchangeFieldNumber = 1;
  const ::std::string& exchange() const;
  void set_exchange(const ::std::string& value);
  #if LANG_CXX11
  void set_exchange(::std::string&& value);
  #endif
  void set_exchange(const char* value);
  void set_exchange(const char* value, size_t size);
  ::std::string* mutable_exchange();
  ::std::string* release_exchange();
  void set_allocated_exchange(::std::string* exchange);

  // bool open = 2;
  void clear_open();
  static const int kOpenFieldNumber = 2;
  bool open() const;
  void set_open(bool value);

  // @@protoc_insertion_point(class_scope:ssigmaapi.markethub.v1.ExchangeStatus)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr exchange_;
  bool open_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_ssigmaapi_2fmarkethub_2fv1_2fmarkethub_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// GetTradesRequest

// repeated .ssigmaapi.type.Market markets = 1;
inline int GetTradesRequest::markets_size() const {
  return markets_.size();
}
inline ::ssigmaapi::type::Market* GetTradesRequest::mutable_markets(int index) {
  // @@protoc_insertion_point(field_mutable:ssigmaapi.markethub.v1.GetTradesRequest.markets)
  return markets_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::ssigmaapi::type::Market >*
GetTradesRequest::mutable_markets() {
  // @@protoc_insertion_point(field_mutable_list:ssigmaapi.markethub.v1.GetTradesRequest.markets)
  return &markets_;
}
inline const ::ssigmaapi::type::Market& GetTradesRequest::markets(int index) const {
  // @@protoc_insertion_point(field_get:ssigmaapi.markethub.v1.GetTradesRequest.markets)
  return markets_.Get(index);
}
inline ::ssigmaapi::type::Market* GetTradesRequest::add_markets() {
  // @@protoc_insertion_point(field_add:ssigmaapi.markethub.v1.GetTradesRequest.markets)
  return markets_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ssigmaapi::type::Market >&
GetTradesRequest::markets() const {
  // @@protoc_insertion_point(field_list:ssigmaapi.markethub.v1.GetTradesRequest.markets)
  return markets_;
}

// int64 velocity_windowing_size = 2;
inline void GetTradesRequest::clear_velocity_windowing_size() {
  velocity_windowing_size_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 GetTradesRequest::velocity_windowing_size() const {
  // @@protoc_insertion_point(field_get:ssigmaapi.markethub.v1.GetTradesRequest.velocity_windowing_size)
  return velocity_windowing_size_;
}
inline void GetTradesRequest::set_velocity_windowing_size(::google::protobuf::int64 value) {
  
  velocity_windowing_size_ = value;
  // @@protoc_insertion_point(field_set:ssigmaapi.markethub.v1.GetTradesRequest.velocity_windowing_size)
}

// int64 volatility_windowing_size = 3;
inline void GetTradesRequest::clear_volatility_windowing_size() {
  volatility_windowing_size_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 GetTradesRequest::volatility_windowing_size() const {
  // @@protoc_insertion_point(field_get:ssigmaapi.markethub.v1.GetTradesRequest.volatility_windowing_size)
  return volatility_windowing_size_;
}
inline void GetTradesRequest::set_volatility_windowing_size(::google::protobuf::int64 value) {
  
  volatility_windowing_size_ = value;
  // @@protoc_insertion_point(field_set:ssigmaapi.markethub.v1.GetTradesRequest.volatility_windowing_size)
}

// int64 volume_windowing_size = 4;
inline void GetTradesRequest::clear_volume_windowing_size() {
  volume_windowing_size_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 GetTradesRequest::volume_windowing_size() const {
  // @@protoc_insertion_point(field_get:ssigmaapi.markethub.v1.GetTradesRequest.volume_windowing_size)
  return volume_windowing_size_;
}
inline void GetTradesRequest::set_volume_windowing_size(::google::protobuf::int64 value) {
  
  volume_windowing_size_ = value;
  // @@protoc_insertion_point(field_set:ssigmaapi.markethub.v1.GetTradesRequest.volume_windowing_size)
}

// -------------------------------------------------------------------

// GetTradesResponse

// repeated .ssigmaapi.markethub.v1.TradesWithMarket trades_with_market = 1;
inline int GetTradesResponse::trades_with_market_size() const {
  return trades_with_market_.size();
}
inline void GetTradesResponse::clear_trades_with_market() {
  trades_with_market_.Clear();
}
inline ::ssigmaapi::markethub::v1::TradesWithMarket* GetTradesResponse::mutable_trades_with_market(int index) {
  // @@protoc_insertion_point(field_mutable:ssigmaapi.markethub.v1.GetTradesResponse.trades_with_market)
  return trades_with_market_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::ssigmaapi::markethub::v1::TradesWithMarket >*
GetTradesResponse::mutable_trades_with_market() {
  // @@protoc_insertion_point(field_mutable_list:ssigmaapi.markethub.v1.GetTradesResponse.trades_with_market)
  return &trades_with_market_;
}
inline const ::ssigmaapi::markethub::v1::TradesWithMarket& GetTradesResponse::trades_with_market(int index) const {
  // @@protoc_insertion_point(field_get:ssigmaapi.markethub.v1.GetTradesResponse.trades_with_market)
  return trades_with_market_.Get(index);
}
inline ::ssigmaapi::markethub::v1::TradesWithMarket* GetTradesResponse::add_trades_with_market() {
  // @@protoc_insertion_point(field_add:ssigmaapi.markethub.v1.GetTradesResponse.trades_with_market)
  return trades_with_market_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ssigmaapi::markethub::v1::TradesWithMarket >&
GetTradesResponse::trades_with_market() const {
  // @@protoc_insertion_point(field_list:ssigmaapi.markethub.v1.GetTradesResponse.trades_with_market)
  return trades_with_market_;
}

// repeated .ssigmaapi.markethub.v1.ExchangeStatus exchange_status = 2;
inline int GetTradesResponse::exchange_status_size() const {
  return exchange_status_.size();
}
inline void GetTradesResponse::clear_exchange_status() {
  exchange_status_.Clear();
}
inline ::ssigmaapi::markethub::v1::ExchangeStatus* GetTradesResponse::mutable_exchange_status(int index) {
  // @@protoc_insertion_point(field_mutable:ssigmaapi.markethub.v1.GetTradesResponse.exchange_status)
  return exchange_status_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::ssigmaapi::markethub::v1::ExchangeStatus >*
GetTradesResponse::mutable_exchange_status() {
  // @@protoc_insertion_point(field_mutable_list:ssigmaapi.markethub.v1.GetTradesResponse.exchange_status)
  return &exchange_status_;
}
inline const ::ssigmaapi::markethub::v1::ExchangeStatus& GetTradesResponse::exchange_status(int index) const {
  // @@protoc_insertion_point(field_get:ssigmaapi.markethub.v1.GetTradesResponse.exchange_status)
  return exchange_status_.Get(index);
}
inline ::ssigmaapi::markethub::v1::ExchangeStatus* GetTradesResponse::add_exchange_status() {
  // @@protoc_insertion_point(field_add:ssigmaapi.markethub.v1.GetTradesResponse.exchange_status)
  return exchange_status_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ssigmaapi::markethub::v1::ExchangeStatus >&
GetTradesResponse::exchange_status() const {
  // @@protoc_insertion_point(field_list:ssigmaapi.markethub.v1.GetTradesResponse.exchange_status)
  return exchange_status_;
}

// -------------------------------------------------------------------

// GetOrderBooksRequest

// repeated .ssigmaapi.type.Market market = 1;
inline int GetOrderBooksRequest::market_size() const {
  return market_.size();
}
inline ::ssigmaapi::type::Market* GetOrderBooksRequest::mutable_market(int index) {
  // @@protoc_insertion_point(field_mutable:ssigmaapi.markethub.v1.GetOrderBooksRequest.market)
  return market_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::ssigmaapi::type::Market >*
GetOrderBooksRequest::mutable_market() {
  // @@protoc_insertion_point(field_mutable_list:ssigmaapi.markethub.v1.GetOrderBooksRequest.market)
  return &market_;
}
inline const ::ssigmaapi::type::Market& GetOrderBooksRequest::market(int index) const {
  // @@protoc_insertion_point(field_get:ssigmaapi.markethub.v1.GetOrderBooksRequest.market)
  return market_.Get(index);
}
inline ::ssigmaapi::type::Market* GetOrderBooksRequest::add_market() {
  // @@protoc_insertion_point(field_add:ssigmaapi.markethub.v1.GetOrderBooksRequest.market)
  return market_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ssigmaapi::type::Market >&
GetOrderBooksRequest::market() const {
  // @@protoc_insertion_point(field_list:ssigmaapi.markethub.v1.GetOrderBooksRequest.market)
  return market_;
}

// -------------------------------------------------------------------

// GetOrderBooksResponse

// repeated .ssigmaapi.type.OrderBook all = 1;
inline int GetOrderBooksResponse::all_size() const {
  return all_.size();
}
inline ::ssigmaapi::type::OrderBook* GetOrderBooksResponse::mutable_all(int index) {
  // @@protoc_insertion_point(field_mutable:ssigmaapi.markethub.v1.GetOrderBooksResponse.all)
  return all_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::ssigmaapi::type::OrderBook >*
GetOrderBooksResponse::mutable_all() {
  // @@protoc_insertion_point(field_mutable_list:ssigmaapi.markethub.v1.GetOrderBooksResponse.all)
  return &all_;
}
inline const ::ssigmaapi::type::OrderBook& GetOrderBooksResponse::all(int index) const {
  // @@protoc_insertion_point(field_get:ssigmaapi.markethub.v1.GetOrderBooksResponse.all)
  return all_.Get(index);
}
inline ::ssigmaapi::type::OrderBook* GetOrderBooksResponse::add_all() {
  // @@protoc_insertion_point(field_add:ssigmaapi.markethub.v1.GetOrderBooksResponse.all)
  return all_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ssigmaapi::type::OrderBook >&
GetOrderBooksResponse::all() const {
  // @@protoc_insertion_point(field_list:ssigmaapi.markethub.v1.GetOrderBooksResponse.all)
  return all_;
}

// int64 timestamp = 2;
inline void GetOrderBooksResponse::clear_timestamp() {
  timestamp_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 GetOrderBooksResponse::timestamp() const {
  // @@protoc_insertion_point(field_get:ssigmaapi.markethub.v1.GetOrderBooksResponse.timestamp)
  return timestamp_;
}
inline void GetOrderBooksResponse::set_timestamp(::google::protobuf::int64 value) {
  
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:ssigmaapi.markethub.v1.GetOrderBooksResponse.timestamp)
}

// repeated .ssigmaapi.markethub.v1.ExchangeStatus exchange_status = 3;
inline int GetOrderBooksResponse::exchange_status_size() const {
  return exchange_status_.size();
}
inline void GetOrderBooksResponse::clear_exchange_status() {
  exchange_status_.Clear();
}
inline ::ssigmaapi::markethub::v1::ExchangeStatus* GetOrderBooksResponse::mutable_exchange_status(int index) {
  // @@protoc_insertion_point(field_mutable:ssigmaapi.markethub.v1.GetOrderBooksResponse.exchange_status)
  return exchange_status_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::ssigmaapi::markethub::v1::ExchangeStatus >*
GetOrderBooksResponse::mutable_exchange_status() {
  // @@protoc_insertion_point(field_mutable_list:ssigmaapi.markethub.v1.GetOrderBooksResponse.exchange_status)
  return &exchange_status_;
}
inline const ::ssigmaapi::markethub::v1::ExchangeStatus& GetOrderBooksResponse::exchange_status(int index) const {
  // @@protoc_insertion_point(field_get:ssigmaapi.markethub.v1.GetOrderBooksResponse.exchange_status)
  return exchange_status_.Get(index);
}
inline ::ssigmaapi::markethub::v1::ExchangeStatus* GetOrderBooksResponse::add_exchange_status() {
  // @@protoc_insertion_point(field_add:ssigmaapi.markethub.v1.GetOrderBooksResponse.exchange_status)
  return exchange_status_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ssigmaapi::markethub::v1::ExchangeStatus >&
GetOrderBooksResponse::exchange_status() const {
  // @@protoc_insertion_point(field_list:ssigmaapi.markethub.v1.GetOrderBooksResponse.exchange_status)
  return exchange_status_;
}

// -------------------------------------------------------------------

// GetTradesAndOrderBooksRequest

// .ssigmaapi.markethub.v1.GetTradesRequest trades_req = 1;
inline bool GetTradesAndOrderBooksRequest::has_trades_req() const {
  return this != internal_default_instance() && trades_req_ != NULL;
}
inline void GetTradesAndOrderBooksRequest::clear_trades_req() {
  if (GetArenaNoVirtual() == NULL && trades_req_ != NULL) {
    delete trades_req_;
  }
  trades_req_ = NULL;
}
inline const ::ssigmaapi::markethub::v1::GetTradesRequest& GetTradesAndOrderBooksRequest::_internal_trades_req() const {
  return *trades_req_;
}
inline const ::ssigmaapi::markethub::v1::GetTradesRequest& GetTradesAndOrderBooksRequest::trades_req() const {
  const ::ssigmaapi::markethub::v1::GetTradesRequest* p = trades_req_;
  // @@protoc_insertion_point(field_get:ssigmaapi.markethub.v1.GetTradesAndOrderBooksRequest.trades_req)
  return p != NULL ? *p : *reinterpret_cast<const ::ssigmaapi::markethub::v1::GetTradesRequest*>(
      &::ssigmaapi::markethub::v1::_GetTradesRequest_default_instance_);
}
inline ::ssigmaapi::markethub::v1::GetTradesRequest* GetTradesAndOrderBooksRequest::release_trades_req() {
  // @@protoc_insertion_point(field_release:ssigmaapi.markethub.v1.GetTradesAndOrderBooksRequest.trades_req)
  
  ::ssigmaapi::markethub::v1::GetTradesRequest* temp = trades_req_;
  trades_req_ = NULL;
  return temp;
}
inline ::ssigmaapi::markethub::v1::GetTradesRequest* GetTradesAndOrderBooksRequest::mutable_trades_req() {
  
  if (trades_req_ == NULL) {
    auto* p = CreateMaybeMessage<::ssigmaapi::markethub::v1::GetTradesRequest>(GetArenaNoVirtual());
    trades_req_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ssigmaapi.markethub.v1.GetTradesAndOrderBooksRequest.trades_req)
  return trades_req_;
}
inline void GetTradesAndOrderBooksRequest::set_allocated_trades_req(::ssigmaapi::markethub::v1::GetTradesRequest* trades_req) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete trades_req_;
  }
  if (trades_req) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      trades_req = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, trades_req, submessage_arena);
    }
    
  } else {
    
  }
  trades_req_ = trades_req;
  // @@protoc_insertion_point(field_set_allocated:ssigmaapi.markethub.v1.GetTradesAndOrderBooksRequest.trades_req)
}

// .ssigmaapi.markethub.v1.GetOrderBooksRequest orderbooks_req = 2;
inline bool GetTradesAndOrderBooksRequest::has_orderbooks_req() const {
  return this != internal_default_instance() && orderbooks_req_ != NULL;
}
inline void GetTradesAndOrderBooksRequest::clear_orderbooks_req() {
  if (GetArenaNoVirtual() == NULL && orderbooks_req_ != NULL) {
    delete orderbooks_req_;
  }
  orderbooks_req_ = NULL;
}
inline const ::ssigmaapi::markethub::v1::GetOrderBooksRequest& GetTradesAndOrderBooksRequest::_internal_orderbooks_req() const {
  return *orderbooks_req_;
}
inline const ::ssigmaapi::markethub::v1::GetOrderBooksRequest& GetTradesAndOrderBooksRequest::orderbooks_req() const {
  const ::ssigmaapi::markethub::v1::GetOrderBooksRequest* p = orderbooks_req_;
  // @@protoc_insertion_point(field_get:ssigmaapi.markethub.v1.GetTradesAndOrderBooksRequest.orderbooks_req)
  return p != NULL ? *p : *reinterpret_cast<const ::ssigmaapi::markethub::v1::GetOrderBooksRequest*>(
      &::ssigmaapi::markethub::v1::_GetOrderBooksRequest_default_instance_);
}
inline ::ssigmaapi::markethub::v1::GetOrderBooksRequest* GetTradesAndOrderBooksRequest::release_orderbooks_req() {
  // @@protoc_insertion_point(field_release:ssigmaapi.markethub.v1.GetTradesAndOrderBooksRequest.orderbooks_req)
  
  ::ssigmaapi::markethub::v1::GetOrderBooksRequest* temp = orderbooks_req_;
  orderbooks_req_ = NULL;
  return temp;
}
inline ::ssigmaapi::markethub::v1::GetOrderBooksRequest* GetTradesAndOrderBooksRequest::mutable_orderbooks_req() {
  
  if (orderbooks_req_ == NULL) {
    auto* p = CreateMaybeMessage<::ssigmaapi::markethub::v1::GetOrderBooksRequest>(GetArenaNoVirtual());
    orderbooks_req_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ssigmaapi.markethub.v1.GetTradesAndOrderBooksRequest.orderbooks_req)
  return orderbooks_req_;
}
inline void GetTradesAndOrderBooksRequest::set_allocated_orderbooks_req(::ssigmaapi::markethub::v1::GetOrderBooksRequest* orderbooks_req) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete orderbooks_req_;
  }
  if (orderbooks_req) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      orderbooks_req = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, orderbooks_req, submessage_arena);
    }
    
  } else {
    
  }
  orderbooks_req_ = orderbooks_req;
  // @@protoc_insertion_point(field_set_allocated:ssigmaapi.markethub.v1.GetTradesAndOrderBooksRequest.orderbooks_req)
}

// -------------------------------------------------------------------

// GetTradesAndOrderBooksResponse

// .ssigmaapi.markethub.v1.GetTradesResponse trades_res = 1;
inline bool GetTradesAndOrderBooksResponse::has_trades_res() const {
  return this != internal_default_instance() && trades_res_ != NULL;
}
inline void GetTradesAndOrderBooksResponse::clear_trades_res() {
  if (GetArenaNoVirtual() == NULL && trades_res_ != NULL) {
    delete trades_res_;
  }
  trades_res_ = NULL;
}
inline const ::ssigmaapi::markethub::v1::GetTradesResponse& GetTradesAndOrderBooksResponse::_internal_trades_res() const {
  return *trades_res_;
}
inline const ::ssigmaapi::markethub::v1::GetTradesResponse& GetTradesAndOrderBooksResponse::trades_res() const {
  const ::ssigmaapi::markethub::v1::GetTradesResponse* p = trades_res_;
  // @@protoc_insertion_point(field_get:ssigmaapi.markethub.v1.GetTradesAndOrderBooksResponse.trades_res)
  return p != NULL ? *p : *reinterpret_cast<const ::ssigmaapi::markethub::v1::GetTradesResponse*>(
      &::ssigmaapi::markethub::v1::_GetTradesResponse_default_instance_);
}
inline ::ssigmaapi::markethub::v1::GetTradesResponse* GetTradesAndOrderBooksResponse::release_trades_res() {
  // @@protoc_insertion_point(field_release:ssigmaapi.markethub.v1.GetTradesAndOrderBooksResponse.trades_res)
  
  ::ssigmaapi::markethub::v1::GetTradesResponse* temp = trades_res_;
  trades_res_ = NULL;
  return temp;
}
inline ::ssigmaapi::markethub::v1::GetTradesResponse* GetTradesAndOrderBooksResponse::mutable_trades_res() {
  
  if (trades_res_ == NULL) {
    auto* p = CreateMaybeMessage<::ssigmaapi::markethub::v1::GetTradesResponse>(GetArenaNoVirtual());
    trades_res_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ssigmaapi.markethub.v1.GetTradesAndOrderBooksResponse.trades_res)
  return trades_res_;
}
inline void GetTradesAndOrderBooksResponse::set_allocated_trades_res(::ssigmaapi::markethub::v1::GetTradesResponse* trades_res) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete trades_res_;
  }
  if (trades_res) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      trades_res = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, trades_res, submessage_arena);
    }
    
  } else {
    
  }
  trades_res_ = trades_res;
  // @@protoc_insertion_point(field_set_allocated:ssigmaapi.markethub.v1.GetTradesAndOrderBooksResponse.trades_res)
}

// .ssigmaapi.markethub.v1.GetOrderBooksResponse orderbooks_res = 2;
inline bool GetTradesAndOrderBooksResponse::has_orderbooks_res() const {
  return this != internal_default_instance() && orderbooks_res_ != NULL;
}
inline void GetTradesAndOrderBooksResponse::clear_orderbooks_res() {
  if (GetArenaNoVirtual() == NULL && orderbooks_res_ != NULL) {
    delete orderbooks_res_;
  }
  orderbooks_res_ = NULL;
}
inline const ::ssigmaapi::markethub::v1::GetOrderBooksResponse& GetTradesAndOrderBooksResponse::_internal_orderbooks_res() const {
  return *orderbooks_res_;
}
inline const ::ssigmaapi::markethub::v1::GetOrderBooksResponse& GetTradesAndOrderBooksResponse::orderbooks_res() const {
  const ::ssigmaapi::markethub::v1::GetOrderBooksResponse* p = orderbooks_res_;
  // @@protoc_insertion_point(field_get:ssigmaapi.markethub.v1.GetTradesAndOrderBooksResponse.orderbooks_res)
  return p != NULL ? *p : *reinterpret_cast<const ::ssigmaapi::markethub::v1::GetOrderBooksResponse*>(
      &::ssigmaapi::markethub::v1::_GetOrderBooksResponse_default_instance_);
}
inline ::ssigmaapi::markethub::v1::GetOrderBooksResponse* GetTradesAndOrderBooksResponse::release_orderbooks_res() {
  // @@protoc_insertion_point(field_release:ssigmaapi.markethub.v1.GetTradesAndOrderBooksResponse.orderbooks_res)
  
  ::ssigmaapi::markethub::v1::GetOrderBooksResponse* temp = orderbooks_res_;
  orderbooks_res_ = NULL;
  return temp;
}
inline ::ssigmaapi::markethub::v1::GetOrderBooksResponse* GetTradesAndOrderBooksResponse::mutable_orderbooks_res() {
  
  if (orderbooks_res_ == NULL) {
    auto* p = CreateMaybeMessage<::ssigmaapi::markethub::v1::GetOrderBooksResponse>(GetArenaNoVirtual());
    orderbooks_res_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ssigmaapi.markethub.v1.GetTradesAndOrderBooksResponse.orderbooks_res)
  return orderbooks_res_;
}
inline void GetTradesAndOrderBooksResponse::set_allocated_orderbooks_res(::ssigmaapi::markethub::v1::GetOrderBooksResponse* orderbooks_res) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete orderbooks_res_;
  }
  if (orderbooks_res) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      orderbooks_res = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, orderbooks_res, submessage_arena);
    }
    
  } else {
    
  }
  orderbooks_res_ = orderbooks_res;
  // @@protoc_insertion_point(field_set_allocated:ssigmaapi.markethub.v1.GetTradesAndOrderBooksResponse.orderbooks_res)
}

// repeated .ssigmaapi.markethub.v1.ExchangeStatus exchange_status = 3;
inline int GetTradesAndOrderBooksResponse::exchange_status_size() const {
  return exchange_status_.size();
}
inline void GetTradesAndOrderBooksResponse::clear_exchange_status() {
  exchange_status_.Clear();
}
inline ::ssigmaapi::markethub::v1::ExchangeStatus* GetTradesAndOrderBooksResponse::mutable_exchange_status(int index) {
  // @@protoc_insertion_point(field_mutable:ssigmaapi.markethub.v1.GetTradesAndOrderBooksResponse.exchange_status)
  return exchange_status_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::ssigmaapi::markethub::v1::ExchangeStatus >*
GetTradesAndOrderBooksResponse::mutable_exchange_status() {
  // @@protoc_insertion_point(field_mutable_list:ssigmaapi.markethub.v1.GetTradesAndOrderBooksResponse.exchange_status)
  return &exchange_status_;
}
inline const ::ssigmaapi::markethub::v1::ExchangeStatus& GetTradesAndOrderBooksResponse::exchange_status(int index) const {
  // @@protoc_insertion_point(field_get:ssigmaapi.markethub.v1.GetTradesAndOrderBooksResponse.exchange_status)
  return exchange_status_.Get(index);
}
inline ::ssigmaapi::markethub::v1::ExchangeStatus* GetTradesAndOrderBooksResponse::add_exchange_status() {
  // @@protoc_insertion_point(field_add:ssigmaapi.markethub.v1.GetTradesAndOrderBooksResponse.exchange_status)
  return exchange_status_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ssigmaapi::markethub::v1::ExchangeStatus >&
GetTradesAndOrderBooksResponse::exchange_status() const {
  // @@protoc_insertion_point(field_list:ssigmaapi.markethub.v1.GetTradesAndOrderBooksResponse.exchange_status)
  return exchange_status_;
}

// -------------------------------------------------------------------

// TradeWithAdditionalInfo

// .ssigmaapi.type.Trade trade = 1;
inline bool TradeWithAdditionalInfo::has_trade() const {
  return this != internal_default_instance() && trade_ != NULL;
}
inline const ::ssigmaapi::type::Trade& TradeWithAdditionalInfo::_internal_trade() const {
  return *trade_;
}
inline const ::ssigmaapi::type::Trade& TradeWithAdditionalInfo::trade() const {
  const ::ssigmaapi::type::Trade* p = trade_;
  // @@protoc_insertion_point(field_get:ssigmaapi.markethub.v1.TradeWithAdditionalInfo.trade)
  return p != NULL ? *p : *reinterpret_cast<const ::ssigmaapi::type::Trade*>(
      &::ssigmaapi::type::_Trade_default_instance_);
}
inline ::ssigmaapi::type::Trade* TradeWithAdditionalInfo::release_trade() {
  // @@protoc_insertion_point(field_release:ssigmaapi.markethub.v1.TradeWithAdditionalInfo.trade)
  
  ::ssigmaapi::type::Trade* temp = trade_;
  trade_ = NULL;
  return temp;
}
inline ::ssigmaapi::type::Trade* TradeWithAdditionalInfo::mutable_trade() {
  
  if (trade_ == NULL) {
    auto* p = CreateMaybeMessage<::ssigmaapi::type::Trade>(GetArenaNoVirtual());
    trade_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ssigmaapi.markethub.v1.TradeWithAdditionalInfo.trade)
  return trade_;
}
inline void TradeWithAdditionalInfo::set_allocated_trade(::ssigmaapi::type::Trade* trade) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(trade_);
  }
  if (trade) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      trade = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, trade, submessage_arena);
    }
    
  } else {
    
  }
  trade_ = trade;
  // @@protoc_insertion_point(field_set_allocated:ssigmaapi.markethub.v1.TradeWithAdditionalInfo.trade)
}

// double velocity = 2;
inline void TradeWithAdditionalInfo::clear_velocity() {
  velocity_ = 0;
}
inline double TradeWithAdditionalInfo::velocity() const {
  // @@protoc_insertion_point(field_get:ssigmaapi.markethub.v1.TradeWithAdditionalInfo.velocity)
  return velocity_;
}
inline void TradeWithAdditionalInfo::set_velocity(double value) {
  
  velocity_ = value;
  // @@protoc_insertion_point(field_set:ssigmaapi.markethub.v1.TradeWithAdditionalInfo.velocity)
}

// double acceleration = 3;
inline void TradeWithAdditionalInfo::clear_acceleration() {
  acceleration_ = 0;
}
inline double TradeWithAdditionalInfo::acceleration() const {
  // @@protoc_insertion_point(field_get:ssigmaapi.markethub.v1.TradeWithAdditionalInfo.acceleration)
  return acceleration_;
}
inline void TradeWithAdditionalInfo::set_acceleration(double value) {
  
  acceleration_ = value;
  // @@protoc_insertion_point(field_set:ssigmaapi.markethub.v1.TradeWithAdditionalInfo.acceleration)
}

// double volatility = 4;
inline void TradeWithAdditionalInfo::clear_volatility() {
  volatility_ = 0;
}
inline double TradeWithAdditionalInfo::volatility() const {
  // @@protoc_insertion_point(field_get:ssigmaapi.markethub.v1.TradeWithAdditionalInfo.volatility)
  return volatility_;
}
inline void TradeWithAdditionalInfo::set_volatility(double value) {
  
  volatility_ = value;
  // @@protoc_insertion_point(field_set:ssigmaapi.markethub.v1.TradeWithAdditionalInfo.volatility)
}

// double volume_base = 5;
inline void TradeWithAdditionalInfo::clear_volume_base() {
  volume_base_ = 0;
}
inline double TradeWithAdditionalInfo::volume_base() const {
  // @@protoc_insertion_point(field_get:ssigmaapi.markethub.v1.TradeWithAdditionalInfo.volume_base)
  return volume_base_;
}
inline void TradeWithAdditionalInfo::set_volume_base(double value) {
  
  volume_base_ = value;
  // @@protoc_insertion_point(field_set:ssigmaapi.markethub.v1.TradeWithAdditionalInfo.volume_base)
}

// double volume_quote = 6;
inline void TradeWithAdditionalInfo::clear_volume_quote() {
  volume_quote_ = 0;
}
inline double TradeWithAdditionalInfo::volume_quote() const {
  // @@protoc_insertion_point(field_get:ssigmaapi.markethub.v1.TradeWithAdditionalInfo.volume_quote)
  return volume_quote_;
}
inline void TradeWithAdditionalInfo::set_volume_quote(double value) {
  
  volume_quote_ = value;
  // @@protoc_insertion_point(field_set:ssigmaapi.markethub.v1.TradeWithAdditionalInfo.volume_quote)
}

// double momentum_rate = 7;
inline void TradeWithAdditionalInfo::clear_momentum_rate() {
  momentum_rate_ = 0;
}
inline double TradeWithAdditionalInfo::momentum_rate() const {
  // @@protoc_insertion_point(field_get:ssigmaapi.markethub.v1.TradeWithAdditionalInfo.momentum_rate)
  return momentum_rate_;
}
inline void TradeWithAdditionalInfo::set_momentum_rate(double value) {
  
  momentum_rate_ = value;
  // @@protoc_insertion_point(field_set:ssigmaapi.markethub.v1.TradeWithAdditionalInfo.momentum_rate)
}

// int64 velocity_windowing_size = 8;
inline void TradeWithAdditionalInfo::clear_velocity_windowing_size() {
  velocity_windowing_size_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 TradeWithAdditionalInfo::velocity_windowing_size() const {
  // @@protoc_insertion_point(field_get:ssigmaapi.markethub.v1.TradeWithAdditionalInfo.velocity_windowing_size)
  return velocity_windowing_size_;
}
inline void TradeWithAdditionalInfo::set_velocity_windowing_size(::google::protobuf::int64 value) {
  
  velocity_windowing_size_ = value;
  // @@protoc_insertion_point(field_set:ssigmaapi.markethub.v1.TradeWithAdditionalInfo.velocity_windowing_size)
}

// int64 volatility_windowing_size = 9;
inline void TradeWithAdditionalInfo::clear_volatility_windowing_size() {
  volatility_windowing_size_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 TradeWithAdditionalInfo::volatility_windowing_size() const {
  // @@protoc_insertion_point(field_get:ssigmaapi.markethub.v1.TradeWithAdditionalInfo.volatility_windowing_size)
  return volatility_windowing_size_;
}
inline void TradeWithAdditionalInfo::set_volatility_windowing_size(::google::protobuf::int64 value) {
  
  volatility_windowing_size_ = value;
  // @@protoc_insertion_point(field_set:ssigmaapi.markethub.v1.TradeWithAdditionalInfo.volatility_windowing_size)
}

// int64 volume_windowing_size = 10;
inline void TradeWithAdditionalInfo::clear_volume_windowing_size() {
  volume_windowing_size_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 TradeWithAdditionalInfo::volume_windowing_size() const {
  // @@protoc_insertion_point(field_get:ssigmaapi.markethub.v1.TradeWithAdditionalInfo.volume_windowing_size)
  return volume_windowing_size_;
}
inline void TradeWithAdditionalInfo::set_volume_windowing_size(::google::protobuf::int64 value) {
  
  volume_windowing_size_ = value;
  // @@protoc_insertion_point(field_set:ssigmaapi.markethub.v1.TradeWithAdditionalInfo.volume_windowing_size)
}

// -------------------------------------------------------------------

// TradesWithMarket

// .ssigmaapi.type.Market market = 1;
inline bool TradesWithMarket::has_market() const {
  return this != internal_default_instance() && market_ != NULL;
}
inline const ::ssigmaapi::type::Market& TradesWithMarket::_internal_market() const {
  return *market_;
}
inline const ::ssigmaapi::type::Market& TradesWithMarket::market() const {
  const ::ssigmaapi::type::Market* p = market_;
  // @@protoc_insertion_point(field_get:ssigmaapi.markethub.v1.TradesWithMarket.market)
  return p != NULL ? *p : *reinterpret_cast<const ::ssigmaapi::type::Market*>(
      &::ssigmaapi::type::_Market_default_instance_);
}
inline ::ssigmaapi::type::Market* TradesWithMarket::release_market() {
  // @@protoc_insertion_point(field_release:ssigmaapi.markethub.v1.TradesWithMarket.market)
  
  ::ssigmaapi::type::Market* temp = market_;
  market_ = NULL;
  return temp;
}
inline ::ssigmaapi::type::Market* TradesWithMarket::mutable_market() {
  
  if (market_ == NULL) {
    auto* p = CreateMaybeMessage<::ssigmaapi::type::Market>(GetArenaNoVirtual());
    market_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ssigmaapi.markethub.v1.TradesWithMarket.market)
  return market_;
}
inline void TradesWithMarket::set_allocated_market(::ssigmaapi::type::Market* market) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(market_);
  }
  if (market) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      market = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, market, submessage_arena);
    }
    
  } else {
    
  }
  market_ = market;
  // @@protoc_insertion_point(field_set_allocated:ssigmaapi.markethub.v1.TradesWithMarket.market)
}

// repeated .ssigmaapi.markethub.v1.TradeWithAdditionalInfo trades = 2;
inline int TradesWithMarket::trades_size() const {
  return trades_.size();
}
inline void TradesWithMarket::clear_trades() {
  trades_.Clear();
}
inline ::ssigmaapi::markethub::v1::TradeWithAdditionalInfo* TradesWithMarket::mutable_trades(int index) {
  // @@protoc_insertion_point(field_mutable:ssigmaapi.markethub.v1.TradesWithMarket.trades)
  return trades_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::ssigmaapi::markethub::v1::TradeWithAdditionalInfo >*
TradesWithMarket::mutable_trades() {
  // @@protoc_insertion_point(field_mutable_list:ssigmaapi.markethub.v1.TradesWithMarket.trades)
  return &trades_;
}
inline const ::ssigmaapi::markethub::v1::TradeWithAdditionalInfo& TradesWithMarket::trades(int index) const {
  // @@protoc_insertion_point(field_get:ssigmaapi.markethub.v1.TradesWithMarket.trades)
  return trades_.Get(index);
}
inline ::ssigmaapi::markethub::v1::TradeWithAdditionalInfo* TradesWithMarket::add_trades() {
  // @@protoc_insertion_point(field_add:ssigmaapi.markethub.v1.TradesWithMarket.trades)
  return trades_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ssigmaapi::markethub::v1::TradeWithAdditionalInfo >&
TradesWithMarket::trades() const {
  // @@protoc_insertion_point(field_list:ssigmaapi.markethub.v1.TradesWithMarket.trades)
  return trades_;
}

// -------------------------------------------------------------------

// ExchangeStatus

// string exchange = 1;
inline void ExchangeStatus::clear_exchange() {
  exchange_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ExchangeStatus::exchange() const {
  // @@protoc_insertion_point(field_get:ssigmaapi.markethub.v1.ExchangeStatus.exchange)
  return exchange_.GetNoArena();
}
inline void ExchangeStatus::set_exchange(const ::std::string& value) {
  
  exchange_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ssigmaapi.markethub.v1.ExchangeStatus.exchange)
}
#if LANG_CXX11
inline void ExchangeStatus::set_exchange(::std::string&& value) {
  
  exchange_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ssigmaapi.markethub.v1.ExchangeStatus.exchange)
}
#endif
inline void ExchangeStatus::set_exchange(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  exchange_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ssigmaapi.markethub.v1.ExchangeStatus.exchange)
}
inline void ExchangeStatus::set_exchange(const char* value, size_t size) {
  
  exchange_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ssigmaapi.markethub.v1.ExchangeStatus.exchange)
}
inline ::std::string* ExchangeStatus::mutable_exchange() {
  
  // @@protoc_insertion_point(field_mutable:ssigmaapi.markethub.v1.ExchangeStatus.exchange)
  return exchange_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ExchangeStatus::release_exchange() {
  // @@protoc_insertion_point(field_release:ssigmaapi.markethub.v1.ExchangeStatus.exchange)
  
  return exchange_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ExchangeStatus::set_allocated_exchange(::std::string* exchange) {
  if (exchange != NULL) {
    
  } else {
    
  }
  exchange_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), exchange);
  // @@protoc_insertion_point(field_set_allocated:ssigmaapi.markethub.v1.ExchangeStatus.exchange)
}

// bool open = 2;
inline void ExchangeStatus::clear_open() {
  open_ = false;
}
inline bool ExchangeStatus::open() const {
  // @@protoc_insertion_point(field_get:ssigmaapi.markethub.v1.ExchangeStatus.open)
  return open_;
}
inline void ExchangeStatus::set_open(bool value) {
  
  open_ = value;
  // @@protoc_insertion_point(field_set:ssigmaapi.markethub.v1.ExchangeStatus.open)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace v1
}  // namespace markethub
}  // namespace ssigmaapi

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_ssigmaapi_2fmarkethub_2fv1_2fmarkethub_2eproto
